/* Regex.c generated by valac 0.26.2, the Vala compiler
 * generated from Regex.vala, do not modify */

/* Copyright (c) Microsoft. All rights reserved.*/
/* Licensed under the MIT license. See LICENSE file in the project root for full license information.*/
/* The Regex class represents a single compiled instance of a regular*/
/* expression.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX (system_text_regular_expressions_static_regex_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX, SystemTextRegularExpressionsStaticRegex))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX, SystemTextRegularExpressionsStaticRegexClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_STATIC_REGEX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_STATIC_REGEX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX, SystemTextRegularExpressionsStaticRegexClass))

typedef struct _SystemTextRegularExpressionsStaticRegex SystemTextRegularExpressionsStaticRegex;
typedef struct _SystemTextRegularExpressionsStaticRegexClass SystemTextRegularExpressionsStaticRegexClass;
typedef struct _SystemTextRegularExpressionsStaticRegexPrivate SystemTextRegularExpressionsStaticRegexPrivate;

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX_OPTIONS (system_text_regular_expressions_regex_options_get_type ())

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE (system_text_regular_expressions_capture_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_CAPTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE, SystemTextRegularExpressionsCapture))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_CAPTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE, SystemTextRegularExpressionsCaptureClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_CAPTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_CAPTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_CAPTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_CAPTURE, SystemTextRegularExpressionsCaptureClass))

typedef struct _SystemTextRegularExpressionsCapture SystemTextRegularExpressionsCapture;
typedef struct _SystemTextRegularExpressionsCaptureClass SystemTextRegularExpressionsCaptureClass;

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP (system_text_regular_expressions_group_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP, SystemTextRegularExpressionsGroup))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP, SystemTextRegularExpressionsGroupClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_GROUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_GROUP, SystemTextRegularExpressionsGroupClass))

typedef struct _SystemTextRegularExpressionsGroup SystemTextRegularExpressionsGroup;
typedef struct _SystemTextRegularExpressionsGroupClass SystemTextRegularExpressionsGroupClass;

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH (system_text_regular_expressions_match_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH, SystemTextRegularExpressionsMatch))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH, SystemTextRegularExpressionsMatchClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH, SystemTextRegularExpressionsMatchClass))

typedef struct _SystemTextRegularExpressionsMatch SystemTextRegularExpressionsMatch;
typedef struct _SystemTextRegularExpressionsMatchClass SystemTextRegularExpressionsMatchClass;
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION (system_text_regular_expressions_match_collection_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION, SystemTextRegularExpressionsMatchCollection))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION, SystemTextRegularExpressionsMatchCollectionClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_MATCH_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_MATCH_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_MATCH_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_MATCH_COLLECTION, SystemTextRegularExpressionsMatchCollectionClass))

typedef struct _SystemTextRegularExpressionsMatchCollection SystemTextRegularExpressionsMatchCollection;
typedef struct _SystemTextRegularExpressionsMatchCollectionClass SystemTextRegularExpressionsMatchCollectionClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _SystemTextRegularExpressionsParamSpecStaticRegex SystemTextRegularExpressionsParamSpecStaticRegex;

#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX (system_text_regular_expressions_regex_get_type ())
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX, SystemTextRegularExpressionsRegex))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX, SystemTextRegularExpressionsRegexClass))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_REGEX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_IS_REGEX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX))
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX, SystemTextRegularExpressionsRegexClass))

typedef struct _SystemTextRegularExpressionsRegex SystemTextRegularExpressionsRegex;
typedef struct _SystemTextRegularExpressionsRegexClass SystemTextRegularExpressionsRegexClass;
typedef struct _SystemTextRegularExpressionsRegexPrivate SystemTextRegularExpressionsRegexPrivate;

struct _SystemTextRegularExpressionsStaticRegex {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SystemTextRegularExpressionsStaticRegexPrivate * priv;
};

struct _SystemTextRegularExpressionsStaticRegexClass {
	GTypeClass parent_class;
	void (*finalize) (SystemTextRegularExpressionsStaticRegex *self);
};

typedef enum  {
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_None = 0x0000,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnoreCase = 0x0001,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Multiline = 0x0002,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ExplicitCapture = 0x0004,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Compiled = 0x0008,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Singleline = 0x0010,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnorePatternWhitespace = 0x0020,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_RightToLeft = 0x0040,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ECMAScript = 0x0100,
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_CultureInvariant = 0x0200
} SystemTextRegularExpressionsRegexOptions;

struct _SystemTextRegularExpressionsParamSpecStaticRegex {
	GParamSpec parent_instance;
};

struct _SystemTextRegularExpressionsRegex {
	SystemTextRegularExpressionsStaticRegex parent_instance;
	SystemTextRegularExpressionsRegexPrivate * priv;
	gchar* _pattern;
	SystemTextRegularExpressionsRegexOptions _roptions;
	GRegex* _regex;
	GTimeSpan _internalMatchTimeout;
	gint _capsize;
};

struct _SystemTextRegularExpressionsRegexClass {
	SystemTextRegularExpressionsStaticRegexClass parent_class;
};


static gpointer system_text_regular_expressions_static_regex_parent_class = NULL;
static gpointer system_text_regular_expressions_regex_parent_class = NULL;
static GTimeSpan system_text_regular_expressions_regex_MaximumMatchTimeout;
static GTimeSpan system_text_regular_expressions_regex_MaximumMatchTimeout = 0LL;
extern GTimeSpan system_text_regular_expressions_regex_InfiniteMatchTimeout;
GTimeSpan system_text_regular_expressions_regex_InfiniteMatchTimeout = 0LL;

gpointer system_text_regular_expressions_static_regex_ref (gpointer instance);
void system_text_regular_expressions_static_regex_unref (gpointer instance);
GParamSpec* system_text_regular_expressions_param_spec_static_regex (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void system_text_regular_expressions_value_set_static_regex (GValue* value, gpointer v_object);
void system_text_regular_expressions_value_take_static_regex (GValue* value, gpointer v_object);
gpointer system_text_regular_expressions_value_get_static_regex (const GValue* value);
GType system_text_regular_expressions_static_regex_get_type (void) G_GNUC_CONST;
enum  {
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_DUMMY_PROPERTY
};
#define SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_DefaultMatchTimeout ((GTimeSpan) (-1))
GType system_text_regular_expressions_regex_options_get_type (void) G_GNUC_CONST;
SystemTextRegularExpressionsStaticRegex* system_text_regular_expressions_static_regex_construct (GType object_type, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options);
gboolean system_text_regular_expressions_static_regex_IsMatch (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout);
GRegexCompileFlags system_text_regular_expressions_static_regex_ConvertOptions (SystemTextRegularExpressionsRegexOptions options);
gpointer system_text_regular_expressions_capture_ref (gpointer instance);
void system_text_regular_expressions_capture_unref (gpointer instance);
GParamSpec* system_text_regular_expressions_param_spec_capture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void system_text_regular_expressions_value_set_capture (GValue* value, gpointer v_object);
void system_text_regular_expressions_value_take_capture (GValue* value, gpointer v_object);
gpointer system_text_regular_expressions_value_get_capture (const GValue* value);
GType system_text_regular_expressions_capture_get_type (void) G_GNUC_CONST;
GType system_text_regular_expressions_group_get_type (void) G_GNUC_CONST;
GType system_text_regular_expressions_match_get_type (void) G_GNUC_CONST;
SystemTextRegularExpressionsMatch* system_text_regular_expressions_static_regex_Match (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout);
SystemTextRegularExpressionsMatch* system_text_regular_expressions_match_new (GMatchInfo* matchinfo);
SystemTextRegularExpressionsMatch* system_text_regular_expressions_match_construct (GType object_type, GMatchInfo* matchinfo);
GType system_text_regular_expressions_match_collection_get_type (void) G_GNUC_CONST;
SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_static_regex_Matches (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout);
SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_match_collection_new (GRegex* regex, const gchar* input, gint beginning, gint length, gint startat);
SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_match_collection_construct (GType object_type, GRegex* regex, const gchar* input, gint beginning, gint length, gint startat);
gchar* system_text_regular_expressions_static_regex_Replace (const gchar* input, const gchar* pattern, const gchar* replacement, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout);
gchar** system_text_regular_expressions_static_regex_Split (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, int* result_length1);
gchar* system_text_regular_expressions_static_regex_Escape (const gchar* str);
gchar* system_text_regular_expressions_static_regex_Unescape (const gchar* str);
static void system_text_regular_expressions_static_regex_finalize (SystemTextRegularExpressionsStaticRegex* obj);
GType system_text_regular_expressions_regex_get_type (void) G_GNUC_CONST;
enum  {
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_DUMMY_PROPERTY
};
SystemTextRegularExpressionsRegex* system_text_regular_expressions_regex_new (const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, gboolean useCache);
SystemTextRegularExpressionsRegex* system_text_regular_expressions_regex_construct (GType object_type, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, gboolean useCache);
gchar* system_text_regular_expressions_regex_ToString (SystemTextRegularExpressionsRegex* self);
gchar** system_text_regular_expressions_regex_GetGroupNames (SystemTextRegularExpressionsRegex* self, int* result_length1);
gint* system_text_regular_expressions_regex_GetGroupNumbers (SystemTextRegularExpressionsRegex* self, int* result_length1);
gchar* system_text_regular_expressions_regex_GroupNameFromNumber (SystemTextRegularExpressionsRegex* self, gint i);
gint system_text_regular_expressions_regex_GroupNumberFromName (SystemTextRegularExpressionsRegex* self, const gchar* name);
gboolean system_text_regular_expressions_regex_IsMatch (SystemTextRegularExpressionsRegex* self, const gchar* input, gint startat);
SystemTextRegularExpressionsMatch* system_text_regular_expressions_regex_Match (SystemTextRegularExpressionsRegex* self, const gchar* input, gint beginning, gint length);
SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_regex_Matches (SystemTextRegularExpressionsRegex* self, const gchar* input, gint startat);
gchar* system_text_regular_expressions_regex_Replace (SystemTextRegularExpressionsRegex* self, const gchar* input, const gchar* replacement, gint count, gint startat);
gchar** system_text_regular_expressions_regex_Split (SystemTextRegularExpressionsRegex* self, const gchar* input, gint count, gint startat, int* result_length1);
gboolean system_text_regular_expressions_regex_UseOptionR (SystemTextRegularExpressionsRegex* self);
gboolean system_text_regular_expressions_regex_UseOptionInvariant (SystemTextRegularExpressionsRegex* self);
gint system_text_regular_expressions_regex_get_CacheSize (void);
void system_text_regular_expressions_regex_set_CacheSize (gint value);
SystemTextRegularExpressionsRegexOptions system_text_regular_expressions_regex_get_Options (SystemTextRegularExpressionsRegex* self);
GTimeSpan system_text_regular_expressions_regex_get_MatchTimeout (SystemTextRegularExpressionsRegex* self);
gboolean system_text_regular_expressions_regex_get_RightToLeft (SystemTextRegularExpressionsRegex* self);
static void system_text_regular_expressions_regex_finalize (SystemTextRegularExpressionsStaticRegex* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


SystemTextRegularExpressionsStaticRegex* system_text_regular_expressions_static_regex_construct (GType object_type, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options) {
	SystemTextRegularExpressionsStaticRegex* self = NULL;
	g_return_val_if_fail (pattern != NULL, NULL);
	self = (SystemTextRegularExpressionsStaticRegex*) g_type_create_instance (object_type);
	return self;
}


gboolean system_text_regular_expressions_static_regex_IsMatch (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout) {
	gboolean result = FALSE;
	GRegexCompileFlags flags = 0;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	GRegexCompileFlags _tmp1_ = 0;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (input != NULL, FALSE);
	g_return_val_if_fail (pattern != NULL, FALSE);
	_tmp0_ = options;
	_tmp1_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp0_);
	flags = _tmp1_;
	_tmp2_ = pattern;
	_tmp3_ = input;
	_tmp4_ = g_regex_match_simple (_tmp2_, _tmp3_, flags, 0);
	result = _tmp4_;
	return result;
}


SystemTextRegularExpressionsMatch* system_text_regular_expressions_static_regex_Match (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout) {
	SystemTextRegularExpressionsMatch* result = NULL;
	GRegex* re = NULL;
	GMatchInfo* matchinfo = NULL;
	GRegexCompileFlags flags = 0;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	GRegexCompileFlags _tmp1_ = 0;
	gboolean matched = FALSE;
	GRegex* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GRegex* _tmp4_ = NULL;
	GRegex* _tmp5_ = NULL;
	GMatchInfo* _tmp10_ = NULL;
	SystemTextRegularExpressionsMatch* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (pattern != NULL, NULL);
	_tmp0_ = options;
	_tmp1_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp0_);
	flags = _tmp1_;
	matched = FALSE;
	_tmp3_ = pattern;
	_tmp4_ = g_regex_new (_tmp3_, 0, 0, &_inner_error_);
	_tmp2_ = _tmp4_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_match_info_free0 (matchinfo);
		_g_regex_unref0 (re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp5_ = _tmp2_;
	_tmp2_ = NULL;
	_g_regex_unref0 (re);
	re = _tmp5_;
	{
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		GMatchInfo* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		_tmp6_ = re;
		_tmp7_ = input;
		_tmp9_ = g_regex_match (_tmp6_, _tmp7_, 0, &_tmp8_);
		_g_match_info_free0 (matchinfo);
		matchinfo = _tmp8_;
		matched = _tmp9_;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_regex_unref0 (_tmp2_);
		_g_match_info_free0 (matchinfo);
		_g_regex_unref0 (re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp10_ = matchinfo;
	_tmp11_ = system_text_regular_expressions_match_new (_tmp10_);
	result = _tmp11_;
	_g_regex_unref0 (_tmp2_);
	_g_match_info_free0 (matchinfo);
	_g_regex_unref0 (re);
	return result;
}


SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_static_regex_Matches (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout) {
	SystemTextRegularExpressionsMatchCollection* result = NULL;
	GRegex* re = NULL;
	GRegexCompileFlags flags = 0;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	GRegexCompileFlags _tmp1_ = 0;
	GRegex* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GRegex* _tmp4_ = NULL;
	GRegex* _tmp5_ = NULL;
	GRegex* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	SystemTextRegularExpressionsMatchCollection* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (pattern != NULL, NULL);
	_tmp0_ = options;
	_tmp1_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp0_);
	flags = _tmp1_;
	_tmp3_ = pattern;
	_tmp4_ = g_regex_new (_tmp3_, flags, 0, &_inner_error_);
	_tmp2_ = _tmp4_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_regex_unref0 (re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp5_ = _tmp2_;
	_tmp2_ = NULL;
	_g_regex_unref0 (re);
	re = _tmp5_;
	_tmp6_ = re;
	_tmp7_ = input;
	_tmp8_ = input;
	_tmp9_ = strlen (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = system_text_regular_expressions_match_collection_new (_tmp6_, _tmp7_, 0, _tmp10_, 0);
	result = _tmp11_;
	_g_regex_unref0 (_tmp2_);
	_g_regex_unref0 (re);
	return result;
}


gchar* system_text_regular_expressions_static_regex_Replace (const gchar* input, const gchar* pattern, const gchar* replacement, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout) {
	gchar* result = NULL;
	GRegex* re = NULL;
	GRegexCompileFlags flags = 0;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	GRegexCompileFlags _tmp1_ = 0;
	GRegex* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GRegexCompileFlags _tmp4_ = 0;
	GRegex* _tmp5_ = NULL;
	GRegex* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GRegex* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (pattern != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp0_ = options;
	_tmp1_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp0_);
	flags = _tmp1_;
	_tmp3_ = pattern;
	_tmp4_ = flags;
	_tmp5_ = g_regex_new (_tmp3_, _tmp4_, 0, &_inner_error_);
	_tmp2_ = _tmp5_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_regex_unref0 (re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp6_ = _tmp2_;
	_tmp2_ = NULL;
	_g_regex_unref0 (re);
	re = _tmp6_;
	_tmp8_ = re;
	_tmp9_ = input;
	_tmp10_ = input;
	_tmp11_ = strlen (_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = replacement;
	_tmp14_ = g_regex_replace (_tmp8_, _tmp9_, (gssize) _tmp12_, 0, _tmp13_, 0, &_inner_error_);
	_tmp7_ = _tmp14_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_regex_unref0 (_tmp2_);
		_g_regex_unref0 (re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp15_ = _tmp7_;
	_tmp7_ = NULL;
	result = _tmp15_;
	_g_free0 (_tmp7_);
	_g_regex_unref0 (_tmp2_);
	_g_regex_unref0 (re);
	return result;
}


gchar** system_text_regular_expressions_static_regex_Split (const gchar* input, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, int* result_length1) {
	gchar** result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	SystemTextRegularExpressionsRegexOptions _tmp2_ = 0;
	GRegexCompileFlags _tmp3_ = 0;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (pattern != NULL, NULL);
	_tmp0_ = pattern;
	_tmp1_ = input;
	_tmp2_ = options;
	_tmp3_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp2_);
	_tmp5_ = _tmp4_ = g_regex_split_simple (_tmp0_, _tmp1_, _tmp3_, 0);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = _vala_array_length (_tmp4_);
	if (result_length1) {
		*result_length1 = _tmp6__length1;
	}
	result = _tmp6_;
	return result;
}


gchar* system_text_regular_expressions_static_regex_Escape (const gchar* str) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = str;
	_tmp1_ = g_regex_escape_string (_tmp0_, -1);
	result = _tmp1_;
	return result;
}


gchar* system_text_regular_expressions_static_regex_Unescape (const gchar* str) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = str;
	_tmp1_ = g_uri_unescape_string (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


GRegexCompileFlags system_text_regular_expressions_static_regex_ConvertOptions (SystemTextRegularExpressionsRegexOptions options) {
	GRegexCompileFlags result = 0;
	GRegexCompileFlags flags = 0;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	flags = 0;
	_tmp0_ = options;
	if ((_tmp0_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_None) != SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_None) {
		SystemTextRegularExpressionsRegexOptions _tmp1_ = 0;
		SystemTextRegularExpressionsRegexOptions _tmp3_ = 0;
		SystemTextRegularExpressionsRegexOptions _tmp5_ = 0;
		SystemTextRegularExpressionsRegexOptions _tmp8_ = 0;
		SystemTextRegularExpressionsRegexOptions _tmp10_ = 0;
		SystemTextRegularExpressionsRegexOptions _tmp12_ = 0;
		_tmp1_ = options;
		if ((_tmp1_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnoreCase) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnoreCase) {
			GRegexCompileFlags _tmp2_ = 0;
			_tmp2_ = flags;
			flags = _tmp2_ | G_REGEX_CASELESS;
		}
		_tmp3_ = options;
		if ((_tmp3_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Multiline) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Multiline) {
			GRegexCompileFlags _tmp4_ = 0;
			_tmp4_ = flags;
			flags = _tmp4_ | G_REGEX_MULTILINE;
		}
		_tmp5_ = options;
		if ((_tmp5_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ExplicitCapture) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ExplicitCapture) {
			SystemTextRegularExpressionsRegexOptions _tmp6_ = 0;
			_tmp6_ = options;
			if ((_tmp6_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Compiled) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Compiled) {
				GRegexCompileFlags _tmp7_ = 0;
				_tmp7_ = flags;
				flags = _tmp7_ | G_REGEX_OPTIMIZE;
			}
		}
		_tmp8_ = options;
		if ((_tmp8_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Singleline) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_Singleline) {
			GRegexCompileFlags _tmp9_ = 0;
			_tmp9_ = flags;
			flags = _tmp9_ | G_REGEX_DOTALL;
		}
		_tmp10_ = options;
		if ((_tmp10_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnorePatternWhitespace) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_IgnorePatternWhitespace) {
			GRegexCompileFlags _tmp11_ = 0;
			_tmp11_ = flags;
			flags = _tmp11_ | G_REGEX_EXTENDED;
		}
		_tmp12_ = options;
		if ((_tmp12_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ECMAScript) == SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_ECMAScript) {
			GRegexCompileFlags _tmp13_ = 0;
			_tmp13_ = flags;
			flags = _tmp13_ | G_REGEX_JAVASCRIPT_COMPAT;
		}
	}
	result = flags;
	return result;
}


static void system_text_regular_expressions_value_static_regex_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void system_text_regular_expressions_value_static_regex_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		system_text_regular_expressions_static_regex_unref (value->data[0].v_pointer);
	}
}


static void system_text_regular_expressions_value_static_regex_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = system_text_regular_expressions_static_regex_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer system_text_regular_expressions_value_static_regex_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* system_text_regular_expressions_value_static_regex_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SystemTextRegularExpressionsStaticRegex* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = system_text_regular_expressions_static_regex_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* system_text_regular_expressions_value_static_regex_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SystemTextRegularExpressionsStaticRegex** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = system_text_regular_expressions_static_regex_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* system_text_regular_expressions_param_spec_static_regex (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SystemTextRegularExpressionsParamSpecStaticRegex* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer system_text_regular_expressions_value_get_static_regex (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX), NULL);
	return value->data[0].v_pointer;
}


void system_text_regular_expressions_value_set_static_regex (GValue* value, gpointer v_object) {
	SystemTextRegularExpressionsStaticRegex* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		system_text_regular_expressions_static_regex_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		system_text_regular_expressions_static_regex_unref (old);
	}
}


void system_text_regular_expressions_value_take_static_regex (GValue* value, gpointer v_object) {
	SystemTextRegularExpressionsStaticRegex* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		system_text_regular_expressions_static_regex_unref (old);
	}
}


static void system_text_regular_expressions_static_regex_class_init (SystemTextRegularExpressionsStaticRegexClass * klass) {
	system_text_regular_expressions_static_regex_parent_class = g_type_class_peek_parent (klass);
	((SystemTextRegularExpressionsStaticRegexClass *) klass)->finalize = system_text_regular_expressions_static_regex_finalize;
}


static void system_text_regular_expressions_static_regex_instance_init (SystemTextRegularExpressionsStaticRegex * self) {
	self->ref_count = 1;
}


static void system_text_regular_expressions_static_regex_finalize (SystemTextRegularExpressionsStaticRegex* obj) {
	SystemTextRegularExpressionsStaticRegex * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX, SystemTextRegularExpressionsStaticRegex);
	g_signal_handlers_destroy (self);
}


GType system_text_regular_expressions_static_regex_get_type (void) {
	static volatile gsize system_text_regular_expressions_static_regex_type_id__volatile = 0;
	if (g_once_init_enter (&system_text_regular_expressions_static_regex_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { system_text_regular_expressions_value_static_regex_init, system_text_regular_expressions_value_static_regex_free_value, system_text_regular_expressions_value_static_regex_copy_value, system_text_regular_expressions_value_static_regex_peek_pointer, "p", system_text_regular_expressions_value_static_regex_collect_value, "p", system_text_regular_expressions_value_static_regex_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SystemTextRegularExpressionsStaticRegexClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) system_text_regular_expressions_static_regex_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SystemTextRegularExpressionsStaticRegex), 0, (GInstanceInitFunc) system_text_regular_expressions_static_regex_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType system_text_regular_expressions_static_regex_type_id;
		system_text_regular_expressions_static_regex_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SystemTextRegularExpressionsStaticRegex", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&system_text_regular_expressions_static_regex_type_id__volatile, system_text_regular_expressions_static_regex_type_id);
	}
	return system_text_regular_expressions_static_regex_type_id__volatile;
}


gpointer system_text_regular_expressions_static_regex_ref (gpointer instance) {
	SystemTextRegularExpressionsStaticRegex* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void system_text_regular_expressions_static_regex_unref (gpointer instance) {
	SystemTextRegularExpressionsStaticRegex* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SystemTextRegularExpressionsRegex* system_text_regular_expressions_regex_construct (GType object_type, const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, gboolean useCache) {
	SystemTextRegularExpressionsRegex* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	SystemTextRegularExpressionsRegexOptions _tmp2_ = 0;
	GTimeSpan _tmp3_ = 0LL;
	GRegex* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	SystemTextRegularExpressionsRegexOptions _tmp6_ = 0;
	GRegexCompileFlags _tmp7_ = 0;
	GRegex* _tmp8_ = NULL;
	GRegex* _tmp9_ = NULL;
	GRegex* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (pattern != NULL, NULL);
	self = (SystemTextRegularExpressionsRegex*) system_text_regular_expressions_static_regex_construct (object_type, "", SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_None);
	_tmp0_ = pattern;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->_pattern);
	self->_pattern = _tmp1_;
	_tmp2_ = options;
	self->_roptions = _tmp2_;
	_tmp3_ = matchTimeout;
	self->_internalMatchTimeout = _tmp3_;
	_tmp5_ = pattern;
	_tmp6_ = options;
	_tmp7_ = system_text_regular_expressions_static_regex_ConvertOptions (_tmp6_);
	_tmp8_ = g_regex_new (_tmp5_, _tmp7_, 0, &_inner_error_);
	_tmp4_ = _tmp8_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp9_ = _tmp4_;
	_tmp4_ = NULL;
	_g_regex_unref0 (self->_regex);
	self->_regex = _tmp9_;
	_tmp10_ = self->_regex;
	_tmp11_ = g_regex_get_capture_count (_tmp10_);
	self->_capsize = _tmp11_;
	_g_regex_unref0 (_tmp4_);
	return self;
}


SystemTextRegularExpressionsRegex* system_text_regular_expressions_regex_new (const gchar* pattern, SystemTextRegularExpressionsRegexOptions options, GTimeSpan matchTimeout, gboolean useCache) {
	return system_text_regular_expressions_regex_construct (SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX, pattern, options, matchTimeout, useCache);
}


gchar* system_text_regular_expressions_regex_ToString (SystemTextRegularExpressionsRegex* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_pattern;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


gchar** system_text_regular_expressions_regex_GetGroupNames (SystemTextRegularExpressionsRegex* self, int* result_length1) {
	gchar** result = NULL;
	gchar** _result_ = NULL;
	gchar** _tmp0_ = NULL;
	gint _result__length1 = 0;
	gint __result__size_ = 0;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	_result_ = _tmp0_;
	_result__length1 = 0;
	__result__size_ = _result__length1;
	_tmp1_ = _result_;
	_tmp1__length1 = _result__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


gint* system_text_regular_expressions_regex_GetGroupNumbers (SystemTextRegularExpressionsRegex* self, int* result_length1) {
	gint* result = NULL;
	gint* _result_ = NULL;
	gint* _tmp0_ = NULL;
	gint _result__length1 = 0;
	gint __result__size_ = 0;
	gint* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_new0 (gint, 0);
	_result_ = _tmp0_;
	_result__length1 = 0;
	__result__size_ = _result__length1;
	_tmp1_ = _result_;
	_tmp1__length1 = _result__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


gchar* system_text_regular_expressions_regex_GroupNameFromNumber (SystemTextRegularExpressionsRegex* self, gint i) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


gint system_text_regular_expressions_regex_GroupNumberFromName (SystemTextRegularExpressionsRegex* self, const gchar* name) {
	gint result = 0;
	GRegex* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (name != NULL, 0);
	_tmp0_ = self->_regex;
	_tmp1_ = name;
	_tmp2_ = g_regex_get_string_number (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


gboolean system_text_regular_expressions_regex_IsMatch (SystemTextRegularExpressionsRegex* self, const gchar* input, gint startat) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GRegex* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (input != NULL, FALSE);
	_tmp1_ = self->_regex;
	_tmp2_ = input;
	_tmp3_ = input;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = startat;
	_tmp7_ = g_regex_match_full (_tmp1_, _tmp2_, (gssize) _tmp5_, _tmp6_, 0, NULL, &_inner_error_);
	_tmp0_ = _tmp7_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _tmp0_;
	return result;
}


SystemTextRegularExpressionsMatch* system_text_regular_expressions_regex_Match (SystemTextRegularExpressionsRegex* self, const gchar* input, gint beginning, gint length) {
	SystemTextRegularExpressionsMatch* result = NULL;
	GMatchInfo* matchinfo = NULL;
	gboolean matched = FALSE;
	SystemTextRegularExpressionsMatch* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (input != NULL, NULL);
	matched = FALSE;
	{
		gboolean _tmp0_ = FALSE;
		GRegex* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		GMatchInfo* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		_tmp1_ = self->_regex;
		_tmp2_ = input;
		_tmp3_ = length;
		_tmp4_ = beginning;
		_tmp6_ = g_regex_match_full (_tmp1_, _tmp2_, (gssize) _tmp3_, _tmp4_, 0, &_tmp5_, &_inner_error_);
		_g_match_info_free0 (matchinfo);
		matchinfo = _tmp5_;
		_tmp0_ = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_match_info_free0 (matchinfo);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		matched = _tmp0_;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_match_info_free0 (matchinfo);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp7_ = system_text_regular_expressions_match_new (matchinfo);
	result = _tmp7_;
	_g_match_info_free0 (matchinfo);
	return result;
}


SystemTextRegularExpressionsMatchCollection* system_text_regular_expressions_regex_Matches (SystemTextRegularExpressionsRegex* self, const gchar* input, gint startat) {
	SystemTextRegularExpressionsMatchCollection* result = NULL;
	GRegex* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	SystemTextRegularExpressionsMatchCollection* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (input != NULL, NULL);
	_tmp0_ = self->_regex;
	_tmp1_ = input;
	_tmp2_ = input;
	_tmp3_ = strlen (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = startat;
	_tmp6_ = system_text_regular_expressions_match_collection_new (_tmp0_, _tmp1_, 0, _tmp4_, _tmp5_);
	result = _tmp6_;
	return result;
}


gchar* system_text_regular_expressions_regex_Replace (SystemTextRegularExpressionsRegex* self, const gchar* input, const gchar* replacement, gint count, gint startat) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	GRegex* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp1_ = self->_regex;
	_tmp2_ = input;
	_tmp3_ = input;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = startat;
	_tmp7_ = replacement;
	_tmp8_ = g_regex_replace (_tmp1_, _tmp2_, (gssize) _tmp5_, _tmp6_, _tmp7_, 0, &_inner_error_);
	_tmp0_ = _tmp8_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp9_ = _tmp0_;
	_tmp0_ = NULL;
	result = _tmp9_;
	_g_free0 (_tmp0_);
	return result;
}


gchar** system_text_regular_expressions_regex_Split (SystemTextRegularExpressionsRegex* self, const gchar* input, gint count, gint startat, int* result_length1) {
	gchar** result = NULL;
	gchar** _tmp0_ = NULL;
	GRegex* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_ = NULL;
	gint _tmp0__length1 = 0;
	gint __tmp0__size_ = 0;
	gchar** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	gchar** _tmp8_ = NULL;
	gint _tmp8__length1 = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (input != NULL, NULL);
	_tmp1_ = self->_regex;
	_tmp2_ = input;
	_tmp3_ = count;
	_tmp4_ = startat;
	_tmp6_ = _tmp5_ = g_regex_split_full (_tmp1_, _tmp2_, (gssize) _tmp3_, _tmp4_, 0, 0, &_inner_error_);
	_tmp0_ = _tmp6_;
	_tmp0__length1 = _vala_array_length (_tmp5_);
	__tmp0__size_ = _tmp0__length1;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp7_ = _tmp0_;
	_tmp7__length1 = _tmp0__length1;
	_tmp0_ = NULL;
	_tmp0__length1 = 0;
	_tmp8_ = _tmp7_;
	_tmp8__length1 = _tmp7__length1;
	if (result_length1) {
		*result_length1 = _tmp8__length1;
	}
	result = _tmp8_;
	_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
	return result;
}


gboolean system_text_regular_expressions_regex_UseOptionR (SystemTextRegularExpressionsRegex* self) {
	gboolean result = FALSE;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_roptions;
	result = (_tmp0_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_RightToLeft) != 0;
	return result;
}


gboolean system_text_regular_expressions_regex_UseOptionInvariant (SystemTextRegularExpressionsRegex* self) {
	gboolean result = FALSE;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_roptions;
	result = (_tmp0_ & SYSTEM_TEXT_REGULAR_EXPRESSIONS_REGEX_OPTIONS_CultureInvariant) != 0;
	return result;
}


gint system_text_regular_expressions_regex_get_CacheSize (void) {
	gint result;
	result = -1;
	return result;
}


void system_text_regular_expressions_regex_set_CacheSize (gint value) {
}


SystemTextRegularExpressionsRegexOptions system_text_regular_expressions_regex_get_Options (SystemTextRegularExpressionsRegex* self) {
	SystemTextRegularExpressionsRegexOptions result;
	SystemTextRegularExpressionsRegexOptions _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->_roptions;
	result = _tmp0_;
	return result;
}


GTimeSpan system_text_regular_expressions_regex_get_MatchTimeout (SystemTextRegularExpressionsRegex* self) {
	GTimeSpan result;
	GTimeSpan _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->_internalMatchTimeout;
	result = _tmp0_;
	return result;
}


gboolean system_text_regular_expressions_regex_get_RightToLeft (SystemTextRegularExpressionsRegex* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = system_text_regular_expressions_regex_UseOptionR (self);
	result = _tmp0_;
	return result;
}


static void system_text_regular_expressions_regex_class_init (SystemTextRegularExpressionsRegexClass * klass) {
	system_text_regular_expressions_regex_parent_class = g_type_class_peek_parent (klass);
	((SystemTextRegularExpressionsStaticRegexClass *) klass)->finalize = system_text_regular_expressions_regex_finalize;
	system_text_regular_expressions_regex_MaximumMatchTimeout = (GTimeSpan) ((G_MAXINT32 - 1) / 1000);
	system_text_regular_expressions_regex_InfiniteMatchTimeout = (GTimeSpan) (-1);
}


static void system_text_regular_expressions_regex_instance_init (SystemTextRegularExpressionsRegex * self) {
}


static void system_text_regular_expressions_regex_finalize (SystemTextRegularExpressionsStaticRegex* obj) {
	SystemTextRegularExpressionsRegex * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_REGEX, SystemTextRegularExpressionsRegex);
	_g_free0 (self->_pattern);
	_g_regex_unref0 (self->_regex);
	SYSTEM_TEXT_REGULAR_EXPRESSIONS_STATIC_REGEX_CLASS (system_text_regular_expressions_regex_parent_class)->finalize (obj);
}


GType system_text_regular_expressions_regex_get_type (void) {
	static volatile gsize system_text_regular_expressions_regex_type_id__volatile = 0;
	if (g_once_init_enter (&system_text_regular_expressions_regex_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SystemTextRegularExpressionsRegexClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) system_text_regular_expressions_regex_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SystemTextRegularExpressionsRegex), 0, (GInstanceInitFunc) system_text_regular_expressions_regex_instance_init, NULL };
		GType system_text_regular_expressions_regex_type_id;
		system_text_regular_expressions_regex_type_id = g_type_register_static (SYSTEM_TEXT_REGULAR_EXPRESSIONS_TYPE_STATIC_REGEX, "SystemTextRegularExpressionsRegex", &g_define_type_info, 0);
		g_once_init_leave (&system_text_regular_expressions_regex_type_id__volatile, system_text_regular_expressions_regex_type_id);
	}
	return system_text_regular_expressions_regex_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



