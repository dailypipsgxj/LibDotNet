/* libdotnet-0.1.vapi generated by valac 0.26.2, do not modify. */

namespace System {
	namespace Collections {
		namespace Generic {
			[CCode (cheader_filename = "libdotnet.h")]
			public class KeyValuePair<TKey,TValue> {
				public KeyValuePair (TKey key, TValue value);
				public string ToString (GLib.StringBuilder s);
				public TKey Key { get; }
				public TValue Value { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public class List<T> : Gee.ArrayList<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IList, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T> {
				public class Enumerator<T> : GLib.Object, System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator, System.IDisposable {
					public T current;
					public System.Collections.Generic.List<T> list;
					public Enumerator (System.Collections.Generic.List<T> list);
				}
				public List (int defaultSize = 0);
				public void AddRange (System.Collections.Generic.IEnumerable<T> collection);
				public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer<T> comparer);
				public virtual void Clear ();
				public virtual bool Contains (T item);
				public void ForEach (System.Action<T> action);
				public System.Collections.Generic.List<T> GetRange (int index, int count);
				public virtual int IndexOf (T item, int index = 0);
				public virtual void Insert (int index, T item);
				public void InsertRange (int index, System.Collections.Generic.IEnumerable<T> collection);
				public int LastIndexOf (T item);
				public int RemoveAll (System.Predicate<T> match);
				public virtual void RemoveAt (int index);
				public void RemoveRange (int index, int count);
				public void Reverse ();
				public void Sort (System.Collections.Generic.IComparer<T>? comparer = null);
				public void TrimExcess ();
				public int Capacity { get; set; }
				public virtual bool IsFixedSize { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			[GenericAccessors]
			public interface ICollection<T> : GLib.Object, Gee.Collection<T>, System.Collections.Generic.IEnumerable<T> {
				public virtual void Add (T item);
				public virtual void Clear ();
				public virtual bool Contains (T item);
				public virtual void CopyTo (T[] array, int arrayIndex);
				public virtual bool Remove (T item);
				public virtual System.Collections.Generic.IEnumerator iterator ();
				public abstract int Count { get; }
				public abstract bool IsReadOnly { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IComparer<T> : GLib.Object {
				public abstract int Compare (T x, T y);
			}
			[CCode (cheader_filename = "libdotnet.h")]
			[GenericAccessors]
			public interface IDictionary<TKey,TValue> : Gee.Map<TKey,TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>> {
				public virtual void Add (TKey key, TValue value);
				public virtual bool ContainsKey (TKey key);
				public virtual bool ContainsValue (TValue value);
				protected virtual bool IsCompatibleKey (GLib.Object key);
				public virtual bool Remove (TKey key);
				public virtual bool TryGetValue (TKey key, out TValue value);
				public abstract System.Collections.Generic.ICollection<TKey> Keys { get; }
				public abstract System.Collections.Generic.ICollection<TValue> Values { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IEnumerable<T> : System.Collections.IEnumerable {
				public abstract System.Collections.Generic.IEnumerator<T> GetEnumerator ();
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IEnumerator<T> : System.IDisposable, System.Collections.IEnumerator {
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IEqualityComparer<T> {
				public abstract bool Equals (T x, T y);
				public abstract int GetHashCode (T obj);
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IList<T> : System.Collections.Generic.ICollection<T> {
				public abstract int IndexOf (T item, int index = 0);
				public abstract void Insert (int index, T item);
				public abstract void RemoveAt (int index);
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IReadOnlyCollection<T> : System.Collections.Generic.IEnumerable<T> {
				public abstract int Count { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IReadOnlyDictionary<TKey,TValue> : System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey,TValue>> {
				public abstract bool ContainsKey (TKey key);
				public abstract bool TryGetValue (TKey key, out TValue value);
				public abstract System.Collections.Generic.IEnumerable<TKey> Keys { get; }
				public abstract System.Collections.Generic.IEnumerable<TValue> Values { get; }
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface IReadOnlyList<T> : System.Collections.Generic.IReadOnlyCollection<T> {
				public abstract T @get (int index);
			}
			[CCode (cheader_filename = "libdotnet.h")]
			public interface ISet<T> : Gee.Set<T>, System.Collections.Generic.ICollection<T> {
				public virtual bool Add (T value);
				public abstract void ExceptWith (System.Collections.Generic.IEnumerable<T> other);
				public abstract void IntersectWith (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool IsProperSubsetOf (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool IsProperSupersetOf (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool IsSubsetOf (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool IsSupersetOf (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool Overlaps (System.Collections.Generic.IEnumerable<T> other);
				public abstract bool SetEquals (System.Collections.Generic.IEnumerable<T> other);
				public abstract void SymmetricExceptWith (System.Collections.Generic.IEnumerable<T> other);
				public abstract void UnionWith (System.Collections.Generic.IEnumerable<T> other);
			}
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public class DictionaryEntry {
			public DictionaryEntry (GLib.Object key, GLib.Object value);
			public GLib.Object Key { get; set; }
			public GLib.Object Value { get; set; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		[Compact]
		public class KeyValuePairs {
			public GLib.Object _key;
			public GLib.Object _value;
			public KeyValuePairs (GLib.Object key, GLib.Object value);
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface ICollection : GLib.Object, System.Collections.IEnumerable {
			public virtual void CopyTo (GLib.Array<GLib.Object> array, int arrayIndex);
			public virtual System.Collections.IEnumerator iterator ();
			public abstract int Count { get; }
			public abstract bool IsSynchronized { get; }
			public abstract GLib.Object SyncRoot { get; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IComparer : GLib.Object {
			public abstract int Compare (GLib.Object x, GLib.Object y);
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IDictionary : Gee.Map, System.Collections.ICollection {
			public virtual void Add (GLib.Object key, GLib.Object value);
			public virtual void Clear ();
			public virtual bool Contains (GLib.Object key);
			public abstract System.Collections.IDictionaryEnumerator GetEnumerator ();
			public virtual void Remove (GLib.Object key);
			public abstract System.Collections.ICollection Keys { owned get; }
			public abstract System.Collections.ICollection Values { owned get; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IDictionaryEnumerator : System.Collections.IEnumerator {
			public abstract System.Collections.DictionaryEntry Entry { owned get; }
			public abstract GLib.Object Key { owned get; }
			public abstract GLib.Object Value { owned get; }
			protected abstract Gee.MapIterator<GLib.Object,GLib.Object> _iterator { get; set; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IEnumerable {
			public abstract System.Collections.IEnumerator GetEnumerator ();
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IEnumerator : GLib.Object {
			public virtual bool MoveNext ();
			public abstract void Reset ();
			public virtual GLib.Object @get ();
			public virtual bool next ();
			public abstract GLib.Object Current { owned get; }
			protected abstract GLib.Object _currentElement { get; set; }
			protected abstract Gee.Iterator<GLib.Object> _iterator { get; set; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IEqualityComparer : GLib.Object {
			public abstract bool Equals (GLib.Object x, GLib.Object y);
			public abstract int GetHashCode (GLib.Object obj);
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IHashCodeProvider {
			public abstract int GetHashCode (GLib.Object obj);
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IList : Gee.List, System.Collections.ICollection {
			public virtual int Add (GLib.Object value);
			public virtual void Clear ();
			public virtual bool Contains (GLib.Object value);
			public virtual int IndexOf (GLib.Object value);
			public virtual void Insert (int index, GLib.Object value);
			public virtual void Remove (GLib.Object value);
			public virtual void RemoveAt (int index);
			public abstract bool IsFixedSize { get; }
			public abstract bool IsReadOnly { get; }
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IStructuralComparable : GLib.Object {
			public abstract int32 CompareTo (GLib.Object other, System.Collections.IComparer comparer);
		}
		[CCode (cheader_filename = "libdotnet.h")]
		public interface IStructuralEquatable : GLib.Object {
			public abstract bool Equals (GLib.Object other, System.Collections.IEqualityComparer comparer);
			public abstract int GetHashCode (System.Collections.IEqualityComparer comparer);
		}
	}
	namespace Diagnostics {
		namespace CodeAnalysis {
		}
		namespace Contracts {
		}
	}
	namespace Globalization {
		namespace CultureInfo {
			[CCode (cheader_filename = "libdotnet.h")]
			public enum StringComparison {
				CurrentCulture,
				CurrentCultureIgnoreCase,
				InvariantCulture,
				InvariantCultureIgnoreCase,
				Ordinal,
				OrdinalIgnoreCase
			}
		}
	}
	namespace Linq {
	}
	namespace Reflection {
	}
	namespace Runtime {
		namespace CompilerServices {
		}
		namespace InteropServices {
		}
		namespace Remoting {
		}
		namespace Serialization {
		}
	}
	namespace Security {
		namespace Permissions {
		}
	}
	namespace Text {
	}
	namespace Threading {
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public class Nullable<T> {
		public Nullable (T value);
		public bool Equals (GLib.Object other);
		public int GetHashCode ();
		public T GetValueOrDefault (T defaultValue);
		public string ToString ();
		public bool HasValue { get; }
		public T Value { get; }
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public interface ICloneable {
		public abstract GLib.Object Clone ();
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public interface IComparable<T> {
		public abstract int CompareTo (T other);
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public interface IDisposable {
		public abstract void Dispose ();
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public interface IEquatable<T> {
		public abstract bool Equals (T other);
	}
	[CCode (cheader_filename = "libdotnet.h")]
	public delegate void Action<T> (T obj);
	[CCode (cheader_filename = "libdotnet.h")]
	public delegate int Comparison<T> (T x, T y);
	[CCode (cheader_filename = "libdotnet.h")]
	public delegate bool Predicate<T> (T obj);
}
